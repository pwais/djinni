# TODO docs
---
name: jheaparray
typedef: 'record'
params: []
prefix: ''
cpp:
  # The name of this type in C++ (without template arguments). Should be fully qualified.
  typename: '::djinni::JHeapArray'
  # The header required in C++ to use your type. Must include "" or <>.
  header: '"bytesort/JHeapArray.hpp"'
  # Only used for "record" types: determines whether it should be passed by-value in C++.
  # If this is false it is always passed as const&
  byValue: true
java:
  # The name of the (fully qualified) Java type to be used.
  typename: 'byte[]'
  # Only used for "record" types: determines the type used when boxing the record is required.
  # This field is the same as "typename" most of the time as records are typically Objects and require no special boxing.
  # However maybe your record has a dedicated boxed type and this field allows you to control that.
  boxed: 'Byte[]'
  # If this is true "typename" is an Object reference (and not a builtin).
  reference: false
  # Controls whether the type parameters as specified in "params" are forwarded as generics to Java.
  # This is useful when templates are only used in C++ (e.g. std::chrono::duration<rep, period> versus java.time.Duration)
  # This should be true by default (even if your type has no parameters) and only set to false if required
  generic: false
  # If the type is a "record" and has "eq" deriving then this string must not be empty.
  # It declares a well-formed expression with a single "%s" format placeholder replaced with the variable for which the hash code is needed
  hash: '%s.hashCode()'
jni:
  # The fully qualified name of the class containing the toCpp/fromCpp methods.
  translator: '::bytesort::djinni::jni::JHeapArray'
  # Where to find the translator class.
  header: '"bytesort/djinni/jni/JHeapArray.hpp"'
  # The type used for representations in JNI (jobject, jint, jbyteArray, etc)
  typename: jHeapArray
  # The mangled type signature of your type to be found by JNI.
  # See the JNI docs for its format
  typeSignature: 'Lbyte[];'
